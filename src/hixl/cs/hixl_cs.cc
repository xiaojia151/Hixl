/**
 * Copyright (c) 2026 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

#include "common/hixl_cs.h"
#include "hixl/hixl_types.h"
#include "common/hixl_log.h"
#include "common/ctrl_msg.h"
#include "common/hixl_checker.h"
#include "common/scope_guard.h"
#include "hixl_cs_server.h"
#include "hixl_cs_client.h"

HixlStatus HixlCSServerCreate(const char *ip, uint32_t port, const EndpointDesc *endpoint_list, uint32_t list_num,
                              const HixlServerConfig *config, HixlServerHandle *server_handle) {
  HIXL_CHECK_NOTNULL(server_handle);
  auto server = new (std::nothrow) hixl::HixlCSServer(ip, port);
  HIXL_CHECK_NOTNULL(server);
  HIXL_DISMISSABLE_GUARD(rollback, ([server]() { delete server; }));
  HIXL_CHK_STATUS_RET(server->Initialize(endpoint_list, list_num, config),
                      "Failed to init hixl cs server, ip:%s, port:%u", ip, port);
  HIXL_DISMISS_GUARD(rollback);
  *server_handle = server;
  HIXL_EVENT("[HixlCSServer] create server success, server_handle:%p", *server_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerDestroy(HixlServerHandle server_handle) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_MAKE_GUARD(release, ([server]() { delete server; }));
  HIXL_CHK_STATUS_RET(server->Finalize(), "Failed to finalize hixl cs server, server_handle:%p", server_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerRegMem(HixlServerHandle server_handle, const char *mem_tag, const HcommMem *mem,
                              MemHandle *mem_handle) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHECK_NOTNULL(mem);
  HIXL_CHK_STATUS_RET(server->RegisterMem(mem_tag, mem, mem_handle), "Failed to register server mem");
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerUnregMem(HixlServerHandle server_handle, MemHandle mem_handle) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHECK_NOTNULL(mem_handle);
  HIXL_CHK_STATUS_RET(server->DeregisterMem(mem_handle), "Failed to deregister server mem, mem_handle:%p", mem_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerListen(HixlServerHandle server_handle, uint32_t backlog) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHK_STATUS_RET(server->Listen(backlog), "Failed to start server listen, backlog:%u", backlog);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientCreate(const char *server_ip, uint32_t server_port, const EndpointDesc *src_endpoint,
                              const EndpointDesc *dst_endpoint, HixlClientHandle *client_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = new (std::nothrow) hixl::HixlCSClient();
  HIXL_CHECK_NOTNULL(client);
  HIXL_DISMISSABLE_GUARD(rollback, ([client]() { delete client; }));
  const auto ret = client->Create(server_ip, server_port, src_endpoint, dst_endpoint);
  HIXL_CHK_STATUS_RET(ret,
                      "Failed to create hixl cs client, "
                      "server_ip:%s, server_port:%u",
                      server_ip, server_port);
  *client_handle = reinterpret_cast<HixlClientHandle>(client);
  HIXL_DISMISS_GUARD(rollback);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientRegMem(HixlClientHandle client_handle, const char *mem_tag, const HcommMem *mem, void **mem_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  HIXL_CHECK_NOTNULL(mem);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  const auto ret = client->RegMem(mem_tag, mem, mem_handle);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientRegMem failed, mem_tag: %s, mem_adrr: %p, mem_size: %u.", mem_tag, mem->addr, mem->size);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientUnregMem(HixlClientHandle client_handle, void *mem_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  const auto ret = client->UnRegMem(mem_handle);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientUnregMem failed");
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientBatchPut(HixlClientHandle client_handle, uint32_t list_num, void **remote_buf_list,
                                const void **local_buf_list, uint64_t *len_list, void **complete_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  HIXL_CHECK_NOTNULL(remote_buf_list);
  HIXL_CHECK_NOTNULL(local_buf_list);
  HIXL_CHECK_NOTNULL(len_list);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  hixl::CommunicateMem com_mem{list_num, remote_buf_list, local_buf_list, len_list};
  const auto ret = client->BatchTransfer(false, com_mem, complete_handle);
  HIXL_CHK_STATUS_RET(ret,
                      "HixlCSClientBatchPut failed, list_num:%u, remote_buf_list=%p, local_buf_list=%p, len_list=%p",
                      list_num, (void *)remote_buf_list, (void *)local_buf_list, (void *)len_list);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientBatchGet(HixlClientHandle client_handle, uint32_t list_num, void **local_buf_list,
                                const void **remote_buf_list, uint64_t *len_list, void **complete_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  HIXL_CHECK_NOTNULL(remote_buf_list);
  HIXL_CHECK_NOTNULL(local_buf_list);
  HIXL_CHECK_NOTNULL(len_list);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  hixl::CommunicateMem com_mem{list_num, local_buf_list, remote_buf_list, len_list};
  const auto ret = client->BatchTransfer(true, com_mem, complete_handle);
  HIXL_CHK_STATUS_RET(ret,
                      "HixlCSClientBatchGet failed, list_num:%u, remote_buf_list=%p, local_buf_list=%p, len_list=%p",
                      list_num, (void *)remote_buf_list, (void *)local_buf_list, (void *)len_list);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientQueryCompleteStatus(HixlClientHandle client_handle, void *complete_handle, int32_t *status) {
  HIXL_CHECK_NOTNULL(client_handle);
  HIXL_CHECK_NOTNULL(complete_handle);
  HIXL_CHECK_NOTNULL(status);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  const auto ret = client->CheckStatus(complete_handle, status);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientQueryCompleteStatus failed");
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientConnectSync(HixlClientHandle client_handle, uint32_t timeout_ms) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = reinterpret_cast<hixl::HixlCSClient *>(client_handle);
  HIXL_CHECK_NOTNULL(client);
  const auto ret = client->Connect(timeout_ms);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientConnect failed, timeout:%u", timeout_ms);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientGetRemoteMem(HixlClientHandle client_handle, HcommMem **remote_mem_list, char ***mem_tag_list,
                                    uint32_t *list_num, uint32_t timeout_ms) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = reinterpret_cast<hixl::HixlCSClient *>(client_handle);
  HIXL_CHECK_NOTNULL(client);
  const auto ret = client->GetRemoteMem(remote_mem_list, mem_tag_list, list_num, timeout_ms);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientGetRemoteMem failed, timeout:%u", timeout_ms);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientDestroy(HixlClientHandle client_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = reinterpret_cast<hixl::HixlCSClient *>(client_handle);
  HIXL_CHECK_NOTNULL(client);
  const auto ret = client->Destroy();
  delete client;
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientDestroy failed");
  return HIXL_SUCCESS;
}

namespace hixl {
HixlStatus HixlCSServerRegProc(HixlServerHandle server_handle, hixl::CtrlMsgType msg_type, hixl::MsgProcessor proc) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHK_STATUS_RET(server->RegProc(msg_type, proc), "Failed to reg proc, msg_type:%d",
                      static_cast<int32_t>(msg_type));
  return HIXL_SUCCESS;
}
}
