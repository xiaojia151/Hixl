/**
 * Copyright (c) 2026 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

#include "endpoint.h"

#include "common/hixl_utils.h"
#include "common/hixl_checker.h"
#include "common/hixl_log.h"

namespace hixl {

Status Endpoint::Initialize() {
  std::lock_guard<std::mutex> lock(mutex_);
  HIXL_CHK_HCCL_RET(HcommEndpointCreate(&endpoint_, &handle_));
  return SUCCESS;
}

Status Endpoint::Finalize() {
  std::lock_guard<std::mutex> lock(mutex_);
  Status ret = SUCCESS;
  for (const auto &it : channels_) {
    auto chn_ret = it.second->Destroy();
    if (chn_ret != SUCCESS) {
      ret = chn_ret;
      HIXL_LOGE(chn_ret, "Destroy channel failed, ret: %d", chn_ret);
    }
  }

  for (const auto &it : reg_mems_) {
    auto mem_handle = it.first;
    auto hccl_ret = HcommMemUnreg(handle_, mem_handle);
    if (hccl_ret != HCCL_SUCCESS) {
      ret = hixl::HcclError2Status(hccl_ret);
      HIXL_LOGE(ret, "HcommMemUnreg failed, ret: %d", hccl_ret);
    }
  }
  reg_mems_.clear();
  auto hccl_ret = HcommEndpointDestroy(handle_);
  if (hccl_ret != HCCL_SUCCESS) {
    ret = hixl::HcclError2Status(hccl_ret);
    HIXL_LOGE(ret, "HcommEndpointDestroy failed, ret: %d", hccl_ret);
  }
  handle_ = nullptr;
  return ret;
}

EndPointHandle Endpoint::GetHandle() const {
  return handle_;
}

const EndpointDesc &Endpoint::GetEndpoint() const {
  return endpoint_;
}

Status Endpoint::RegisterMem(const char *mem_tag, const HcommMem &mem, MemHandle &mem_handle) {
  std::lock_guard<std::mutex> lock(mutex_);
  HIXL_CHK_HCCL_RET(HcommMemReg(handle_, mem, &mem_handle));
  HixlMemDesc desc{};
  if (mem_tag != nullptr) {
    desc.tag = mem_tag;
  }
  desc.mem = mem;
  reg_mems_[mem_handle] = desc;
  return SUCCESS;
}

Status Endpoint::DeregisterMem(MemHandle mem_handle) {
  std::lock_guard<std::mutex> lock(mutex_);
  auto it = reg_mems_.find(mem_handle);
  if (it == reg_mems_.end()) {
    HIXL_LOGW("mem handle:%p is not registered, please use the handle generated by register mem.", mem_handle);
    return SUCCESS; 
  }
  HIXL_CHK_HCCL_RET(HcommMemUnreg(handle_, mem_handle));
  reg_mems_.erase(it);
  return SUCCESS;
}

Status Endpoint::ExportMem(std::vector<HixlMemDesc> &mem_descs) {
  std::lock_guard<std::mutex> lock(mutex_);
  for (auto &it : reg_mems_) {
    auto mem_handle = it.first;
    auto &mem = it.second;
    if (mem.export_desc == nullptr) {
      HIXL_CHK_HCCL_RET(HcommMemExport(handle_, mem_handle, &mem.export_desc, &mem.export_len));
    }
    mem_descs.emplace_back(mem);
  }
  return SUCCESS;
}

Status Endpoint::CreateChannel(const EndpointDesc &remote_endpoint, ChannelHandle &channel_handle) {
  std::lock_guard<std::mutex> lock(mutex_);
  HIXL_CHK_BOOL_RET_STATUS(handle_ != nullptr, FAILED, "[channel] CreateChannel called before Initialize");
  CommEngine engine = CommEngine::COMM_ENGINE_RESERVED;
  if (endpoint_.loc.locType == EndpointLocType::ENDPOINT_LOC_TYPE_HOST) {
    engine = CommEngine::COMM_ENGINE_CPU;
  } else if (endpoint_.loc.locType == EndpointLocType::ENDPOINT_LOC_TYPE_DEVICE) {
    engine = CommEngine::COMM_ENGINE_AICPU;
  } else {
    HIXL_LOGE(PARAM_INVALID, "[channel] invalid endpoint location=%d",
              static_cast<int32_t>(endpoint_.loc.locType));
    return PARAM_INVALID;
  }
  HcommChannelDesc ch_desc{};
  ch_desc.remoteEndpoint = remote_endpoint;
  ch_desc.notifyNum = 1U;
  ChannelPtr channel = MakeShared<Channel>();
  HIXL_CHECK_NOTNULL(channel);
  Status ret = channel->Create(handle_, ch_desc, engine);
  HIXL_CHK_STATUS_RET(ret, "[Channel] Create failed in Endpoint::CreateChannel");
  ChannelHandle h = channel->GetChannelHandle();
  channels_[h] = channel;
  channel_handle = h;
  return SUCCESS;
}

Status Endpoint::GetChannelStatus(ChannelHandle channel_handle, int32_t *status_out) {
  HIXL_CHECK_NOTNULL(status_out);
  std::lock_guard<std::mutex> lock(mutex_);
  auto it = channels_.find(channel_handle);
  HIXL_CHK_BOOL_RET_STATUS(it != channels_.end(), PARAM_INVALID,
                           "GetChannelStatus failed, channel not found, handle=%lu", channel_handle);
  return it->second->GetStatus(channel_handle, status_out);
}

Status Endpoint::DestroyChannel(ChannelHandle channel_handle) {
  std::lock_guard<std::mutex> lock(mutex_);
  auto it = channels_.find(channel_handle);
  HIXL_CHK_BOOL_RET_STATUS(it != channels_.end(), PARAM_INVALID,
                           "DestroyChannel failed, channel not found, handle=%lu", channel_handle);

  Status ret = it->second->Destroy();
  HIXL_CHK_STATUS_RET(ret, "Channel::Destroy failed, handle=%lu", channel_handle);

  channels_.erase(it);
  HIXL_LOGI("Endpoint::DestroyChannel success, handle=%lu", channel_handle);
  return SUCCESS;
}

Status Endpoint::MemImport(const void *mem_desc, uint32_t desc_len, HcommBuf &out_buf) {
  std::lock_guard<std::mutex> lock(mutex_);
  HIXL_CHECK_NOTNULL(handle_);
  HIXL_CHECK_NOTNULL(mem_desc);

  HIXL_CHK_HCCL_RET(HcommMemImport(handle_, mem_desc, desc_len, &out_buf));
  return SUCCESS;
}

Status Endpoint::GetMemDesc(MemHandle mem_handle, HixlMemDesc &desc) {
  std::lock_guard<std::mutex> lock(mutex_);
  auto it = reg_mems_.find(mem_handle);
  if (it != reg_mems_.end()) {
    desc = it->second;
    return SUCCESS;
  }
  return PARAM_INVALID;
}

}  // namespace hixl
